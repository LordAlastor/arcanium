use Libraries.Game.Game
use Libraries.Game.GameDisplay
use Libraries.Game.DesktopConfiguration
use Libraries.Game.DesktopDisplay
use Libraries.Game.GameDisplay 
use Libraries.Game.ScreenResolution
use Libraries.Game.Graphics.Label
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Color
use Libraries.Game.InputMonitor
use Libraries.Game.InputSet
use Libraries.Game.InputTable
use Libraries.Game.Collision.Shapes.CollisionShape2D
use Libraries.Interface.Events.KeyboardEvent
use Libraries.Interface.Events.CollisionListener2D
use Libraries.Interface.Events.CollisionEvent2D
use Libraries.Interface.Controls.Button
use Libraries.Interface.Layouts.Layout
use Libraries.System.Console
use Libraries.Interface.Behaviors.Behavior
use Libraries.Containers.Array
use Libraries.Interface.Item2D
use Libraries.Game.Graphics.ImageSheet
use Libraries.Game.Graphics.Camera      // Adds Camera

class Main is Game, CollisionListener2D
//==============================================================================
//                             VARIABLE DECLARATION
//==============================================================================    
   
    //Application Configurations
    DesktopConfiguration deskConfig
    DesktopDisplay deskDisplay
    
    //Queue for storing subsequent Behaviors
    BehaviorQueue behaviorQueue

    //Queue for removing objects
    Array<Item2D> removalArray

    //Entities
    Map map1
    Player player1
	
    // For Interaction testing      -Ryan
    Array<Interactable> npcList
    Camera camera = undefined  // Camera

    //For drawing images
    Drawable testmap
    Drawable player
    Drawable box
    Drawable background
    Color color   

    //For player movement
    number newX = 0
    number newY = 0
    number plyrSpeed = 100
    KeyboardEvent keys
    InputMonitor monitor

    //Input Sets
    InputTable controlTable
    InputSet upButton
    InputSet downButton
    InputSet leftButton
    InputSet rightButton
    InputSet selectButton
    InputSet backButton
    InputSet menuButton

    //Map Names
    //TO-DO: Export this in the future to a file that we can directly reference in this file
    MapList maps
 
    //For animations
    Animation test1
    Animation test2
    number elapsedTime = 0
    number fps = 4
    number currentFrame = 1
    number spaceX = 0
    number spaceY = 0
    text spriteImgSheet = "girl"
    text spriteFrame = "Girl"
    text spriteImage = "alien"

    //For audio
    GameAudioManager audioManager

//==============================================================================
//                             PREBUILT ACTIONS
//==============================================================================
    
    action Main

        StartGame()
    end

    action CreateGame

    upButton:SetKeyboardInput(keys:W)
    downButton:SetKeyboardInput(keys:S)
    leftButton:SetKeyboardInput(keys:A)
    rightButton:SetKeyboardInput(keys:D)
    selectButton:SetKeyboardInput(keys:SPACE)
    backButton:SetKeyboardInput(keys:Q)
    menuButton:SetKeyboardInput(keys:I)
        //SetResolution()
//        CreateBackground()
//        InitializeMap(map1, maps:FOREST_MAP)
//        InitializePlayer(player1)
//        LoadAboveLayer(map1, maps:FOREST_MAP)

        //==TEST CALLS==
        CombatTest()
        //InitializeAnimTest()
        //InitializeAudioTest()
    end

    action Update(number seconds)

        // Check if Behaviors are queued
        behaviorQueue:Update(seconds)

//        PlayerMovement(seconds)

        // Necessary for removing unneeded objects
        repeat until removalArray:IsEmpty()
            Remove(removalArray:RemoveFromFront())
        end
    end

//==============================================================================
//                             CUSTOM ACTIONS
//==============================================================================
	  
    action AddToRemove(Item2D item)
        removalArray:Add(item)
    end

    action InitializeMap(Map currMap, Text mapName)
    //Loads map image, collision, and adds it to layer.
        EnablePhysics2D(true)
        currMap:loadMap(mapName)
        currMap:loadCollisionLayer(mapName)
        Add(currMap:testMap)
        i = 0
        repeat currMap:collisions:GetSize() times
            Add(currMap:collisions:Get(i))
            i = i + 1
        end
	AddCollisionListener(me)	
    end

    action LoadAboveLayer(Map currMap, Text mapName)
        currMap:loadAboveLayer(mapName)
        Add(currMap:aboveLayer)
    end

    action InitializePlayer(Player player)
        //Loads player image, enables collision/movement, does NOT add to layer.
        player:DrawPlayer()
        player:playerSprite:EnablePhysics(true)
        player:playerSprite:CanRotate(false)
        player:playerSprite:SetResponsive()
        player:playerSprite:SetName("player")
        Add(player:playerSprite)

        //Sets camera onto player.
        camera = GetCamera2D()
        camera:SetPosition(player1:playerSprite:GetX(), player1:playerSprite:GetY(), 0)
        //camera:SetZoom(2)
    end

    action PlayerMovement(number seconds)
         // Movement using WASD
        // Get current location
        newY = player1:playerSprite:GetY()
        newX = player1:playerSprite:GetX()

        // Add/Sub to both X and Y based on keys
        if monitor:IsKeyPressed(keys:W)
            newY = newY + plyrSpeed * seconds
            
            // for animation -- commented out for testing
            /*newY = testAnimation:girl:GetY() + plyrSpeed * seconds
            //for animation
            if elapsedTime >= 1/fps
                frame = frame + 1
            if frame > 3
                frame = 1 
            end
            testAnimation:ChangeFrame()
            elapsedTime = elapsedTime - 1/fps
            end*/
        end
        if monitor:IsKeyPressed(keys:S)
            newY = newY - plyrSpeed * seconds
        end
        if monitor:IsKeyPressed(keys:D)
            newX = newX + plyrSpeed * seconds
        end
        if monitor:IsKeyPressed(keys:A)
            newX = newX - plyrSpeed * seconds
        end

        // Checks if PLAYER is out of bounds
        if newY < 0
            newY = 0
        end
        if newX < 0
            newX = 0
        end
        if newY > map1:testMap:GetHeight() - player1:playerSprite:GetHeight()
            newY = map1:testMap:GetHeight() - player1:playerSprite:GetHeight()
        end
        if newX > map1:testMap:GetWidth() - player1:playerSprite:GetWidth()
            newX = map1:testMap:GetWidth() - player1:playerSprite:GetWidth()
        end

        player1:playerSprite:SetPosition(newX,newY)
        camera = GetCamera2D()
        camera:SetPosition(player1:playerSprite:GetX(), player1:playerSprite:GetY(), 0)

    end

    action CheckForInteraction(CollisionEvent2D event, boolean entering)

    // This action checks if the collision involes the player
    // and an Interactable Object.  If so, it toggles the
    // interactable such that presing [SPACE] should proceed
    // with the given dialoge.
    // * The checking is based on the NAME of the DRAWABLES
    //   > Interactable MUST inherit Drawable for type casting

    /***********************************************************************
    Collision detection for Interactable Objects (NPCs, Objects, etc.)
    It is currently commented-out so that nothing breaks
                                                        - Ryan
    ***********************************************************************/
///*      MAIN INTERACTABLE ACITON - ALLOWS FOR INTERACTIONS W/ PLAYER
        // Variable used to determine if interaction is available
        boolean interaction = false
        boolean alreadyInteracting = false

        // Cast collision items as Drawables to use them
        Drawable itemA = cast(Drawable, event:GetItemA())
        Drawable itemB = cast(Drawable, event:GetItemB())

        // If PLAYER is in front (added later), swap items
        if itemB:GetName() = "player"
            Drawable itemC = itemB
            itemB = itemA
            itemA = itemC
        end

        // Check if PLAYER & INTERACTABLE
        if itemA:GetName() = "player"
            if itemB:GetName() = "interactable"
                interaction = true
            end
        end
        
        // If interaction is available, enable/disable it
        if interaction
            Interactable newItemB = cast(Interactable, itemB)

            i = 0
            repeat npcList:GetSize() times
                if npcList:Get(i):IsInteracting()
                    alreadyInteracting = true
                end
                i = i + 1
            end

            if entering and not alreadyInteracting
                newItemB:ToggleInteraction("newItemB")
            elseif not entering
                if newItemB:IsInteracting()
                    output ""
                    newItemB:ToggleInteraction("newItemB")
                end
            end
        end
    end

    action SetMap(Map newMap)
        map1 = newMap
    end

    action GetPlayer() returns Player
        return player1
    end

    action SetNpcList(Array<Interactable> newList)
        npcList = newList
    end

    action SetResolution()
        Array<ScreenResolution> array = GetAvailableResolutions()
        ScreenResolution resolution = array:Get(21) //800x600 144hz
        SetScreenResolution(resolution)
    end

    action CreateBackground()
        Drawable background
        background:LoadFilledRectangle(1920*2,1080*2)
        background:SetPosition(-1920/2, -1080/2)
        Add(background)
    end

//==============================================================================
//                          Input Rebinding
//==============================================================================

    action RebindKey(InputSet in)
        KeyboardEvent key
        repeat until key:keyCode not= 0
        end
        in:SetKeyboardInput(key:keyCode)
    end

//==============================================================================
//                             FOR TESTING
//==============================================================================

    action CombatTest()
        /***********************************************************************
        Setup for loading a Battle (test version for now, will be adapted to
        the generalized loading a Level setup in the future.

                                                            - Matt
        ***********************************************************************/
        Player player   //placeholder for now
        Array<number> currentElementsEffectiveness
        currentElementsEffectiveness:Add(1.0)
        currentElementsEffectiveness:Add(0.7)
        currentElementsEffectiveness:Add(1.0)
        currentElementsEffectiveness:Add(1.0)
        currentElementsEffectiveness:Add(0.5)
        currentElementsEffectiveness:Add(1.0)
        Array<integer> currentElementTokens
        currentElementTokens:Add(4)
        currentElementTokens:Add(4)
        currentElementTokens:Add(4)
        currentElementTokens:Add(4)
        currentElementTokens:Add(4)
        currentElementTokens:Add(4)
        player:SetStats("<Player>", 2000, 2000, 5, 5, 0, 1, 1, currentElementsEffectiveness, currentElementTokens)
        player:SetGame(me)
        player:SetRemovalArray(removalArray)
        player:SetBehaviorQueue(behaviorQueue)
        Enemy enemy

        Battle battle
        battle:SetGame(me)
        battle:SetRemovalArray(removalArray)
        battle:SetBehaviorQueue(behaviorQueue)
        battle:LoadLevel()
        battle:Initialize(player, enemy)
        inCombat = true

    end
    
    action InitializeAnimTest()
        // Load images for sample animations
        test1:LoadImageSheet(spriteImgSheet)
        test1:LoadFrame(spriteFrame)
        Add(test1:sprite1)
        test2:LoadImage(spriteImage)
        Add(test2:sprite2)
        test2:sprite2:Scale(0.25)
    end

    action InitializeAudioTest()
        /**************************************************************
                        Ryan's Audio Testing Section
          * Currently does nothing as I didn't add any test files
          * Has examples of using the GameAudioManager:
            > Adding a sound effect (GameSound)
            > Adding music (Music)
            > Playing music
        **************************************************************/
        // Add each audio file to the GameAudioManager
        // * Example of adding a sound effect
//        audioManager:AddAudio("Effect_01", "wav", "effect")

        // * Example of adding music
//        audioManager:AddAudio("Music_01", "ogg", "music")

        // * Example of playing specific music
        audioManager:PlayAudio("Music_01")
    end

end

//==============================================================================
//               COMMENTED OUT CODE (FOR REUSE OR FOR DELETION)
//============================================================================== 


//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

//        ***********************************************************************/
//        INTERACTABLES CODE (MOVE THIS ALL TO A FUNCTION, (CTRL + /) TO UNCOMMENT), MOVED BY ALBERT
//        ***********************************************************************/
//
//        /***********************************************************************
//        Start test section
//        * It should load the FOREST with 3 objects with different interactions
//        * PLAYER should use [SPACE] to trigger behaviors
//          1. Black box, no collision    (dialogue)
//            - 3 Lines of dialogue
//          2. Clear box, with collision  (dialogue)
//            - 2 Lines of dialogue (overlaps the chair in the map)
//          3. White box, no collision    (transition)
//            - Transitions to CASTLE
//                                                                  -Ryan
//        ***********************************************************************/
//
//        // Add INTERACTABLEs to the game (Currently 3)
//        // * This part is currently HARD-CODED for testing
//        // * Likely parse a JSON file of INTERACTABLEs info
//        // * Could store the INTERACTABLE LIST with each map (Edit Map.quorum)
//        integer index = 0
//        repeat until index = 3
//            // Create a new INTERACTABLE to add to the LIST
//            Interactable fillerInteractable
//            npcList:Add(fillerInteractable)
//			
//            // Hard-Coded Objects to add for testing
//            if index = 0
//                // A clear box overlapping the CHAIR in the MAP
//                // Interacts via DIALOGUE
//                npcList:Get(index):CreateInteractable("Wooden Chair", "clear", 11, 5.5, true)
//                DialogueBehavior newDialogue1
//                newDialogue1:AddDialogue("There is a chair infront of you.")
//                newDialogue1:AddDialogue("It is TANGIBLE.")
//                npcList:Get(index):SetInteractableBehavior(newDialogue1, "dialogue")
//            elseif index = 1
//                // A black box that has no collision
//                // Interacts via DIALOGUE
//                npcList:Get(index):CreateInteractable("Black Box", "default", 10, 4, false)
//                DialogueBehavior newDialogue1
//                newDialogue1:AddDialogue("You cannot touch this black box (INTANGIBLE).")
//                newDialogue1:AddDialogue("It shows interaction without physical collision.")
//                newDialogue1:AddDialogue("It is under your sprite (due to being before later).")
//                npcList:Get(index):SetInteractableBehavior(newDialogue1, "dialogue")
//            elseif index = 2
//                // A cyan box that has no collision
//                // Interacts via MAP-TRANSITION
//                npcList:Get(index):CreateInteractable("Back to Castle", "clear", 0, 4, false)
//                npcList:Get(index):LoadFilledRectangle(32,32,color:Cyan())
//                MapTransitionBehavior newTransition1
//                newTransition1:SetTransition(map1, maps:CASTLE_MAP, npcList)
//                newTransition1:SetCoordinates(16, 12)

//                // Test Section of adding INTERACTABLEs to the new MAP
//                Interactable newInteractable
//                newInteractable:CreateInteractable("Back to Forest", "clear", 17, 12, false)
//                newInteractable:LoadFilledRectangle(32,32,color:Cyan())
//                MapTransitionBehavior newTransition2
//                newTransition2:SetTransition(map1, maps:FOREST_MAP, npcList)
//                newTransition2:SetCoordinates(1, 4)
//
////    // THIS PART DOES NOT WORK
////    //            j = 0
////    //            repeat npcList:GetSize() times
////    //                newTransition2:AddNPC(npcList:Get(j))
////    //                j = j + 1
////    //            end
//
//                newInteractable:SetInteractableBehavior(newTransition2, "transition")
//                newTransition1:AddNPC(newInteractable)
//
//                npcList:Get(index):SetInteractableBehavior(newTransition1, "transition")
//            end
//			
//            // Add the INTERACTABLEs to the game
//            Add(npcList:Get(index))
//            AddKeyboardListener(npcList:Get(index))
//            index = index + 1
//        end
//		
//        // Add the PLAYER after everything to be in the foreground
//        Add(player1:playerSprite)
//
//        // Add the above layers
//        map1:loadAboveLayer(maps:FOREST_MAP)
//        Add(map1:aboveLayer)
//		
//        // Set the camera
//        camera = GetCamera2D()
//        camera:SetPosition(player1:playerSprite:GetX() + 200, player1:playerSprite:GetY() + 200, 0)
//        /***********************************************************************
//        End test Section
//        ***********************************************************************/


//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

    /**********************************************************************
        TESTING RYAN'S LOGIC - used to accept player input
    ***********************************************************************/

//        // Movement using WASD
//        // Get current location
//        newY = player1:playerSprite:GetY()
//        newX = player1:playerSprite:GetX()
//
//        // Add/Sub to both X and Y based on keys
//        if monitor:IsKeyPressed(keys:W)
//            newY = newY + plyrSpeed * seconds
//            
//            // for animation -- commented out for testing
//            /*newY = testAnimation:girl:GetY() + plyrSpeed * seconds
//            //for animation
//            if elapsedTime >= 1/fps
//                frame = frame + 1
//            if frame > 3
//                frame = 1 
//            end
//            testAnimation:ChangeFrame()
//            elapsedTime = elapsedTime - 1/fps
//            end*/
//        end
//        if monitor:IsKeyPressed(keys:S)
//            newY = newY - plyrSpeed * seconds
//        end
//        if monitor:IsKeyPressed(keys:D)
//            newX = newX + plyrSpeed * seconds
//        end
//        if monitor:IsKeyPressed(keys:A)
//            newX = newX - plyrSpeed * seconds
//        end
//
//        // Checks if PLAYER is out of bounds
//        if newY < 0
//            newY = 0
//        end
//        if newX < 0
//            newX = 0
//        end
//        if newY > map1:testMap:GetHeight() - player1:playerSprite:GetHeight()
//            newY = map1:testMap:GetHeight() - player1:playerSprite:GetHeight()
//        end
//        if newX > map1:testMap:GetWidth() - player1:playerSprite:GetWidth()
//            newX = map1:testMap:GetWidth() - player1:playerSprite:GetWidth()
//        end
//
//        player1:playerSprite:SetPosition(newX,newY)
        
    /**********************************************************************
        END OF PLAYER INPUT LOGIC
    ***********************************************************************/  
	

//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

    /**********************************************************************
    More sample animations 
    ***********************************************************************/

        /*spaceX = test2:sprite2:GetX() + 50 * seconds
        spaceY = test2:sprite2:GetY() + 50 * seconds
        test2:sprite2:SetPosition(spaceX, spaceY)
        */

        // Animation without using keys
        /*elapsedTime = elapsedTime + seconds
        if elapsedTime >= 1/fps
            currentFrame = test:GetFrame()
            test:SetFrame(currentFrame + 1)
            test:ChangeFrame(spriteFrame)
            elapsedTime = elapsedTime - 1/fps
        end*/
    
    /***********************************************************************
        Sprite Animation
		- Jania & Maria
    ***********************************************************************/	
	
	/*
	// 	UPDATED - commented out for testing
            if monitor:IsKeyPressed(keys:W)
            newY = test1:sprite1:GetY() + plyrSpeed * seconds
            elapsedTime = elapsedTime + seconds
            if elapsedTime >= 1/fps
                currentFrame = test1:GetFrame()
                test1:SetFrame(currentFrame + 1)
                test1:ChangeFrame(spriteFrame)
                elapsedTime = elapsedTime - 1/fps
            end

        elseif monitor:IsKeyPressed(keys:S)
            newY = test1:sprite1:GetY() - plyrSpeed * seconds
            elapsedTime = elapsedTime + seconds
            if elapsedTime >= 1/fps
                currentFrame = test1:GetFrame()
                testAnimation:SetFrame(currentFrame + 1)
                test1:ChangeFrame(spriteFrame)
                elapsedTime = elapsedTime - 1/fps
            end

        elseif monitor:IsKeyPressed(keys:D)
            newX = test1:sprite1:GetX() + plyrSpeed * seconds
            elapsedTime = elapsedTime + seconds
            if elapsedTime >= 1/fps
                currentFrame = test1:GetFrame()
                test1:SetFrame(currentFrame + 1)
                test1:ChangeFrame(spriteFrame)
                elapsedTime = elapsedTime - 1/fps
            end

        elseif monitor:IsKeyPressed(keys:A)
            newX = test1:sprite1:GetX() - plyrSpeed * seconds
            elapsedTime = elapsedTime + seconds
        if elapsedTime >= 1/fps
            currentFrame = test1:GetFrame()
            test1:SetFrame(currentFrame + 1)
            test1:ChangeFrame(spriteFrame)
            elapsedTime = elapsedTime - 1/fps
        end
    end
        
        test1:sprite1:SetPosition(newX,newY)
    */